## Index
전공서적을 사고 맨 뒷장을 보면, index가 있습니다. 내가 알고 싶은 단어에 대한 설명을 보고 싶을 때 index를 보면 그 단어가 설명되어 있는 페이지 번호가 명시되어 있는 걸 보신 적이 있을 겁니다.   
이 개념 그대로, DBMS index도 동일합니다.  

| 책 | | 데이터베이스 |   
|:----:|:---:|:----:|  
| 책 내용 |→| 많은 양의 데이터 |  
| index에 명시된 페이지 번호 |→| index |  


수십만 건의 테이블을 조회할 경우, 엄청난 시간이 소요됩니다.  
컬럼 값과 레코드가 저장된 주소를 `key`와 `value`쌍으로 인덱스를 만들어 둠으로써 우리는 빠른 속도로 데이터를 읽어올 수 있다.  

DBMS의 index는 항상 정렬된 상태를 유지하고 있어, index를 사용하는 컬럼을 이용하여 조회할 경우 빠른 속도로 조회할 수 있지만 
새로운 값을 추가/삭제/수정하는 경우에는 속도가 느려집니다.  
→ 따라서 조회하는 로직이 많고 추가/삭제/수정하는 로직이 적은 경우에 index를 사용하도록 합니다.   

<br/>

## index 자료구조
* **B+-Tree Index Algorithm**  
일반적으로 사용되는 인덱스 알고리즘입니다. 기존 값으로 인덱싱하는 알고리즘입니다.  
* **Hash Index Algorithm**  
기존 값으로 hash 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠르게 검색할 수 있습니다. 시간복잡도 O(1)

👉 `where` 조건절에는 부등호 연산(<>)도 포함이 되어 hash index algorithm은 적합하지 않습니다.  


<br/>
<br/>

#### index는 추가`insert`, 수정`update`, 삭제`delete`가 많은 경우 비효율적이다.
#### primary key가 자동으로 index로 설정되듯이, 되도록 값이 unique하고 문자열인 컬럼을 index로 설정하도록 하자.  
- 동등조건(=)말고도 부등호(<>)로 `where절`을 쓸 수 있는 경우, index가 제 역할을 하지 못합니다. 해당 범위에 있는 데이터들을 다 조회해오기 때문입니다. _ex) 나이_
- 값이 2-3개로 나뉘어지는 경우도 index가 제 역할을 하지 못합니다. 다른 index로 값을 재조회해야 하는 경우가 다수이기 때문입니다. _ex) 성별_

#### index의 순서도 중요하다.  (composite index)
예를 들어 `프로그램제목`, `pd명` 으로 순서로 index가 있다고 하자.  
pd명인 `김태호`로 검색하고 난 후, `무한도전`으로 찾기 보다는 `무한도전`으로 먼저 검색하는 게 더 빠릅니다.