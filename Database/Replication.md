# Replication

### 정의
한 서버에서 다른 서버로 데이터가 동기화 되는 것
- 소스서버(마스터): 원본 데이터를 가지는 서버
- 레플리카서버(슬레이브): 복제된 데이터를 가지는 서버

(MySQL Replication 기준으로 내용 정리)

Replication을 사용하는 이유 👉 **DB 부하를 줄이기 위함**

<br/><br/><br/>

### Replication 서버를 구축하는 목적 🤔

1. Scale-Out
   - 부하를 줄이기 위하여 서버를 늘리는 것
   - 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조이다.
   - 하나의 서버에서 감당하던 쿼리를 여러 서버가 나눠서 감당한다.
2. 데이터 백업
   - 백업 과정은 실제 실행 중인 쿼리들에 영향을 줄 수 있다.
   - 레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업 시 발생하는 문제들을 해결할 수 있다.
3. 데이터 분석
   - 데이터 분석의 경우 대량의 데이터를 조회하는 경우가 많고 쿼리 자체가 무거운 경우가 많다.
   - 무거운 작업 서버에서 실행 시 서비스에 문제가 발생할 가능성이 커짐
   - 레플리카 서버에서 분석용 쿼리만 전용으로 하는 것이 좋다.
4. 데이터의 지리적 분산
   - 특정 지역에서만 사용되는 서비스는 없다. 대부분 전세계적으로 서비스가 진행되는데 서버가 멀리있을 경우 빠른 응답이 어렵다.
     - 애플리케이션 서버와 DB 서버 통신시간이 늘어남
   - 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는 것이 좋다.


<br/><br/><br/>

### Replication은 어떤 원리로 동작하는가? 🤔

* 바이너리 로그
  * MySQL 서버에서 발생하는 모든 변경사항(데이터, 데이터베이스나 테이블의 구조, 계정이나 권한 변경 정보)을 별도의 로그 파일에 순서대로 저장
- MySQL의 Replication은 이 바이너리 로그 기반으로 구현되어 있다.
- `show binary logs` 입력시 바이너리 로그 파일 목록을 볼 수 있다.
- `show master status` 입력시 파일명과 위치 정보를 알 수 있다. 
  - 바이너리 로그 파일 위치 기반으로 바이너리 로그를 식별할 때 사용하는 파일명과 위치
- 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤 
  자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버의 데이터 동기화가 이루어진다.

> 💡 바이너리 로그에 변경내역이 있다는 것을 알고 이를 통해 복제가 이루어진다.

<br/>

#### MySQL에서 3개의 스레드를 통해 복제가 이루어진다.
- Binary Log Dump Thread (소스서버)
  - 바이너리 로그를 레플리카 서버로 전송하는 역할
  - 레플리카 서버가 소스 서버에 연결되면 소스서버에서 내부적으로 Binary Log Dump Thread를 생성한다.
- Replication I/O Thread (레플리카서버)
  - Binary Log Dump Thread가 보낸 Binary Log Event를 가져와 로컬 서버에 파일(Relay Log)로 저장하는 역할
  - 복제가 시작되면 스레드가 생성되고 복제가 멈추면 스레드는 종료된다.
  - Connection Metadata
    - 소스서버와 레플리카 서버를 연결할 때 사용하는 정보
    - `mysql.slave_master_info` 테이블에 저장된다.
    - 버전에 따라 파일로 관리되는 경우도 있다. 
      - MySQL 데이터 디렉토리에 파일 형태로 저장된다.
- Replication SQL Thread (레플리카서버)
  - Replication I/O Thread에 의해 작성된 Relay Log 파일의 이벤트를 읽고 실행하는 역할
  - Applier
    - Relay Log에 저장된 소스 서버 이벤트를 서버에 적용하는 컴포넌트
  - Applier Metadata
    - 이벤트가 지정된 Relay Log 파일명과 파일 내 위치 정보
    - 이 정보를 바탕으로 레플리카 서버에 이벤트들을 적용한다.
    - `mysql.slave_relay_log_info` 테이블에 저장된다.

<br/><br/><br/>

### 바이너리 로그는 어떻게 식별하는가? 🤔
- MySQL 복제를 사용하려면 소스서버에서 반드시 바이너리 로그가 활성화되어 있어야 한다.
- 바이너리 로그가 기록되는 지는 `show master status`를 통해 확인할 수 있다.


- 바이너리 로그 변경 내역을 찾는 방식은 2가지가 있다.
1. **바이너리 로그 파일 위치 기반** 으로 식별하는 방법
- 이벤트 하나를 소스서버의 바이너리 로그 파일명과 파일내 위치값 조합으로 식별한다.
- `server-id`
  - 이벤트 별로 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 MySQL의 `server-id`가 사용된다. 
  - `server-id`를 지정 안하면 기본값으로 1이 된다. 레플리카 서버에서는 반드시 `server-id`를 지정해줘야 한다. 
  - 레플리케이션에 참여하는 각 서버마다 다른 `server_id`를 지정해줘야 한다.
- MySQL 5.5버전까지는 해당 방식만 가능
- 단점
  - 식별 과정이 소스 서버에서만 유효하다.
  - 동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 저장된다는 보장이 없음
2. **글로벌 트랜잭션 ID (GTID) 기반** 으로 식별하는 방법
- 복제에 참여한 모든 MySQL 서버들에서 각 이벤트에 고유한 식별값을 가짐

<br/><br/><br/>

### 바이너리 로그는 어떻게 기록될까? 🤔
- `set global binlog_format = 'STATEMENT'`와 같은 형식으로 기록 방식을 변경할 수 있다.

1. Statement 방식
  - SQL문을 바이너리 로그에 그대로 기록하는 방식
  - MYSQL에 바이너리 로그가 처음 도입되었을 때부터 존재한 포맷
  - 트랜잭션의 격리 수준이 반드시 `REPEATABLE-READ`이상이어야 한다.
    - 이하 방식에서는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 스냅숏이 달라질 수 있다.  
    👉 소스 서버와 레플리카 서버의 데이터가 일치하지 않을 수 있음  
    EX) 비확정적 쿼리 (delete / update에 order by 없이 limit 사용 등)
2. Row 방식
- 데이터 변경이 발생했을 때 변경된 데이터 자체를 기록하는 방식
- MySQL 5.7.7 버전 이후부터 바이너리 로그 기본 포맷
- 장점
  - 어떤 형태의 쿼리든지 복제시 소스서버와 레플리카 서버의 데이터를 일관되게 한다.
- 단점
  - 많은 데이터를 변경하면 모든 데이터가 전부 기록되어 바이너리 로그 파일이 단시간에 매우 커진다.
  - 어떤 쿼리들이 넘어왔고 현재 실행중인 쿼리가 어떤 것인지 레플리카 서버에서는 확인할 수 없다.
3. Mixed 방식
- Statement 방식 + Row 방식 장단점 혼합하여 사용하는 방식
- Statement 방식으로 기록되는 경우 안전하지 않는 경우라고 판단이 들면 Row 포맷으로 변환되어 기록된다.


<br/><br/><br/>


### 복제 동기화 방식
MySQL에서는 복제 동기화에 대해 두 가지 방식을 제공한다.
1. 비동기복제
- 소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 전달됐는지 확인하지 않는다.
- 소스 서버에서 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다.
2. 반동기복제
- 레플리카 서버로 부터 확인 응답을 받은 후 커밋하게 되고 그 이후 클라이언트에게 결과를 반환하게 된다.   
👉 적어도 하나의 레플리카 서버에 트랜잭션이 전송됨을 보장  
👉 전송이 보장된거지 실제 적용이 보장되는 것은 아님
- 서버의 응답을 기다리기 때문에 트랜잭션 처리가 느려질 수 있다.
- 응답이 안오면 무기한적으로 기다릴 수 있기 때문에 소스 서버는 지정된 타임아웃 시간동안 응답이 없으면 비동기 복제 방식으로 전환된다.


<br/><br/><br/>


### 그렇다면 소스서버와 레플리카 서버는 어떻게 구성할까? 🤔 하나씩?
- 구성 방식에도 여러가지가 있다. 👉 5가지
1. 싱글 레플리카 복제
- 하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제형태
- 소스 서버에 문제 생겼을 때 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용
2. 멀티 레플리카 복제
- 하나의 소스 서버에 두 개 이상의 레플리카 서버를 연결한 복제형태
- 하나의 서버는 예비용, 다른 서버는 읽기 요청 처리를 분산하는 용도
3. 체인 복제
- 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 때 사용하는 방식
- 소스 서버가 해야 할 바이너리 로그 배포 역할을 새로운 서버로 넘길 수 있다.
4. 듀얼 소스 복제
- 두 개의 서버가 서로 소스 서버이자 레플리카 서버로 구성되어 있는 형태
- 두 서버 모두 쓰기 가능
  - 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기 발생하여 두 서버는 서로 동일한 데이터를 갖게 됨
  - 목적에 따라 ACTIVE-PASSIVE 형태, ACTIVE-ACTIVE 형태로 사용할 수 있다.
- 싱글 레플리카와 다르게 한 서버에서 문제 발생 시 전환을 바로 가져갈 수 있다.
5. 멀티 소스 복제
- 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태
- 여러 서버에 존재하는 다른 데이터를 하나의 서버로 통합하거나 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합할 때 사용할 수 있다.  
  _(샤딩? 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법)_




<br/><br/><br/>

[출처](https://www.youtube.com/watch?v=95bnLnIxyWI)  
