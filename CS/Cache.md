# Cache
값을 미리 복사해 놓은 임시 장소  
캐시의 접근시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다.   

메모리보다는 빠르고 CPU보다는 느린 cache를 메모리와 CPU사이에 위치시켜 CPU가 접근하는 시간을 줄여준다.  
CPU에서 사용할 데이터들을 메모리에서 가져와 저장한다. (캐시메모리) 

캐시를 사용하게 되면 성능이 좋아지지만 비용이 비싸다.  
또한 캐시가 커지면 주소해독에 대한 주변 회로가 복잡해져서 성능이 마냥 좋아지지만은 않는다.  

### 캐시 메모리 작동 원리
* **시간 지역성 (Temporal Locality)**    
한 번 참조된 데이터는 잠시 후 또 참조될 가능성이 높다.  
* **공간 지역성 (Spatial Locality)**  
참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높다.

CPU가 요청한 데이터가 캐시에 있으면 `Cache Hit` 없어서 DRAM에서 가져오면 `Cache Miss`  

### Cache Miss 
* **Cold Miss**  
: 해당 메모리 주소를 처음 불러서 나는 miss  
_ex) 프로그램을 새로 실행하는 경우 발생_  
* **Conflict Miss**  
: 캐시 메모리에 A데이터와 B데이터를 저장해야 하는데, A와 B가 같은 캐시 메모리 주소에 할당되어서 나는 miss  
_ex) 내가 휴대폰과 따뜻한 커피캔은 항상 외투 오른쪽 주머니에만 넣는 습관이 있다고 하자. 
평상시에는 오른쪽 주머니에 휴대폰만 넣고 다니는데, 어느 날 친구에게 커피캔을 받아서 잠시 휴대폰을 가방 속에 넣어두고 
커피캔을 오른쪽 주머니에 넣었다. 이때 휴대폰을 오른쪽 주머니에서 찾으려고 한다면 그때 conflict miss가 난다._
* **Capacity Miss**  
: 캐시 메모리 공간이 부족해서 나는 miss   
conflict miss는 캐시에 공간이 남아도는데도 불구하고 주소 할당 때문에 나는 미스지만, capacity miss는 주소 할당이 잘 되어있더라도 _공간이 부족하면 나는 미스_   
  캐시 공간이 작아서 벌어지는 일이므로 캐시 크기를 키우면 해결되지만, 캐시 크기를 키우면 캐시 접근속도가 느려지고 파워를 많이 먹는다는 단점이 생긴다.


### Cache Algorithm
* **LRU(Least Recently Used) Algorithm**  
: 캐시에서 메모리를 다루기 위해 사용되는 알고리즘으로 가장 오랫동안 참조되지 않은 데이터를 우선적으로 교체하는 기법이다.  
`LinkedList`를 이용한 `Queue`로 이루어지고 접근의 성능 개선을 위해 `Map`을 같이 사용한다.  

👉 좀 더 찾아보고 공부하기!  


<br/><br/>


[참고](https://namu.moe/w/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC)


